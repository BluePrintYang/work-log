## log

### [**微信的海量IM聊天消息序列号生成**](http://www.52im.net/thread-1998-1-1.html)

> 每个用户独立的64位 sequence 的体系，而不是用一个全局的64位（或更高位） sequence ，很大原因是全局唯一的 sequence 会有非常严重的申请互斥问题，不容易去实现一个高性能高可靠的架构

> 一个巨大的64位数组，每一个微信用户，都在这个大数组里独占一格8 bytes 的空间，这个格子就放着用户已经分配出去的最后一个 sequence：cur_seq。每个用户来申请sequence的时候，只需要将用户的cur_seq+=1，保存回数组，并返回给用户。

> 只要求递增，并没有要求连续

**于是我们实现了一个简单优雅的策略：**

- 1）内存中储存最近一个分配出去的sequence：cur_seq，以及分配上限：max_seq；
- 2）分配sequence时，将cur_seq++，同时与分配上限max_seq比较：如果cur_seq > max_seq，将分配上限提升一个步长max_seq += step，并持久化max_seq；
- 3）重启时，读出持久化的max_seq，赋值给cur_seq。



重启时要读取大量的max_seq数据加载到内存中

### 分号段共享存储

> uid 相邻的一段用户属于一个号段，而同个号段内的用户共享一个 max_seq，这样大幅减少了max_seq 数据的大小，同时也降低了IO次数





目的：保证消息的顺序性，客户端根据消息 id 是否连续判断从服务端拉消息

目前方案：针对不同会话，消息序列id连续递增（使用redis）

缺点：redis宕机服务不可用

先发出的消息拿到的id可能滞后



离线消息



客户端方案：

记录消息id区间：本地的和间断的



## learn

### 每日一题



